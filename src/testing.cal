namespace testing:
    import all math;
    import all counters;

    List(type:double, size=M*K) A = [
        1,1,1,1,1,1,1,1,
        2,2,2,2,2,-2,2,2,
        3,3,3,3,3,3,3,3,
        -1,4,4,4,4,4,-4,4,
        5,5,5,5,50,5,5,5,
        6,6,6,6,6,6,6,6,
        -6,7,7,7,7,7,7,7,
        8,8,8,8,8,8,8,9
    ];

    actor SourceA(uint rows, uint cols) ==> double OutA, uint OutM, uint OutK:
        uint index_A := 0;
        bool tsize := false;

        transmit_size:
            action ==> OutM:[rows], OutK:[cols]
            guard not tsize
            do
                tsize := true;
            end
        
        transmit_data:
            action ==> OutA:[A[index_A-1]]
            guard tsize = true, index_A < rows * cols
            do
                index_A := index_A + 1;
            end
        end

    actor SourceRandom(uint rows, uint cols) ==> double OutA, uint OutM, uint OutK:
        uint index := 0;
        bool tsize := false;

        transmit_size:
            action ==> OutM:[rows], OutK:[cols]
            guard not tsize
            do
                tsize := true;
            end
        
        transmit_data:
            action ==> OutA:[value]
            guard tsize = true, index < rows * cols
            var
                value := random(0.0, 100.0)
            do
                index := index + 1;
            end
        end

    actor SourceALoop(uint rows, uint cols, uint loops) ==> double OutA:
        uint index_A := 0;
        uint loop_count := 0;
        
        transmit_data:
            action ==> OutA:[A[index_A-1]]
            guard loops = 0 || loop_count < loops
            do
                if index_A + 1 > rows * cols then
                    index_A := 0;
                    loop_count := loop_count + 1;
                end
                index_A := index_A + 1;
            end
        end

    actor SourceRandomLoop(uint rows, uint cols, uint loops) ==> double OutA:
        uint index := 0;
        uint loop_count := 0;

        transmit_data:
            action ==> OutA:[value]
            guard loops = 0 || loop_count <= loops
            var
                value := random(0.0, 100.0)
            do
                if index > rows * cols then
                    index := 0;
                    loop_count := loop_count + 1;
                end
                index := index + 1;
            end
        end

    // Simply calculates the throughput of inputs values received
    actor ThroughputBenchmark(uint(size=32) seconds) double In ==>:
        uint(size=32) relativeStartTime;

        uint(size=64) tokenCounter;
        uint(size=64) lastTokenCounter;

        initialize ==> 
        do
            relativeStartTime := timeMSec();
            tokenCounter := 0;
            lastTokenCounter := 0;
        end

        action In:[_] ==>
        var
            uint(size=32) currentTime
        do
            // -- Increase the token Counter
            tokenCounter := tokenCounter + 1;

            // -- Get the current time
            currentTime := timeMSec();
            
            // -- Display the Throuhgput every defined seconds
            if (currentTime - relativeStartTime > seconds * 1000) then
                begin
                var 
                    double throuhgput
                do
                    throuhgput := 1000 * (tokenCounter - lastTokenCounter) / (currentTime - relativeStartTime);
                    relativeStartTime := currentTime;
                    lastTokenCounter := tokenCounter;

                    println("Throughput : " + throuhgput + " tokens/sec");
                end    
            end
        end
    end
end