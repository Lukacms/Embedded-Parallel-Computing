namespace io:

    uint(size=32) NB_TOKEN_TO_SENT = 4096;
	uint NB_TOKEN_TO_SENT_FB = 524288;

	external procedure source_init()
    end

	external procedure source_readNBytes(List(type:uint(size=8)) outTable, uint nbTokenToRead)
    end
	
	external function source_readByte() --> uint(size=8)
    end

	external function source_sizeOfFile() --> int(size=32)
	end

	external procedure source_rewind()
	end

	// Deprecated method, will be removed in the future
	external procedure source_decrementNbLoops()
	end

	// Deprecated method, will be removed in the future
	external function source_isMaxLoopsReached() --> bool
	end
	
	external function source_getNbLoop() --> int
	end

	// Copied to std.stdio.Exit, remove from std.stdio.Source?
	external procedure source_exit(int exitCode)
	end

    actor FileSource () ==> uint(size=1) Out :

        List(type:uint(size=8), size=NB_TOKEN_TO_SENT) bytesRead;

        uint(size=32) iterationLoop := 0;
        uint(size=32) nbByteLeft;
        uint(size=13) nbByteToSend := 0;
        uint(size=13) nbByteSent := 0;
        uint(size=32) nbIteration;

        initialize ==>
        do
            source_init();
        end
        
        getFileSize: action ==>
        guard
            source_sizeOfFile() > 0,
            not source_isMaxLoopsReached()
        var
            uint(size=32) nbBytes
        do
            nbBytes := source_sizeOfFile();
            nbIteration := nbBytes / NB_TOKEN_TO_SENT;
            nbByteLeft := nbBytes mod NB_TOKEN_TO_SENT;
        end
        
        termination: action ==>
        guard
            source_isMaxLoopsReached()
        end

        readNBytes: action ==>
        guard
            iterationLoop < nbIteration
        do
            source_readNBytes(bytesRead, NB_TOKEN_TO_SENT);
            nbByteToSend := NB_TOKEN_TO_SENT;
            nbByteSent := 0;
            iterationLoop := iterationLoop + 1;
        end
        
        readEndOfFile: action ==>
        guard
            nbByteLeft > 0
        do
            source_readNBytes(bytesRead, nbByteLeft);
            nbByteToSend := nbByteLeft;
            nbByteSent := 0;
        end
        
        readFileDone: action ==>
        do
            source_decrementNbLoops();
            source_rewind();
        end
        
        sendData.launch: action ==> Out:[ Out ]
        guard
            nbByteToSend > nbByteSent
        var
            uint(size=8) Out
        do
            Out := bytesRead[nbByteSent];
            nbByteSent := nbByteSent + 1;
        end
        
        sendData.done: action ==>
        guard
            nbByteToSend = nbByteSent
        end
        
        schedule fsm ReadInit :
            ReadInit (getFileSize) --> ReadFile;
            ReadInit (termination) --> Termination;
        
            ReadFile (readNBytes   ) --> SendData;
            ReadFile (readEndOfFile) --> SendLastData;
            ReadFile (readFileDone ) --> ReadFile;
        
            SendData (sendData.launch) --> SendData;
            SendData (sendData.done  ) --> ReadFile;
        
            SendLastData (sendData.launch) --> SendLastData;
            SendLastData (sendData.done  ) --> ReadFileDone;
        end
        
        priority
            termination > getFileSize;
            readNBytes > readEndOfFile > readFileDone;
            sendData.launch > sendData.done;
        end
    end


end