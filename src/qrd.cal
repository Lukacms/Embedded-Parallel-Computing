namespace qrd:
    import all math;

    int M = 8;   // M rows of matrix
    int K = 8;   // K columns of matrix

    List(type:double, size=M*K) A = [
        1,1,1,1,1,1,1,1,
        2,2,2,2,2,2,2,2,
        3,3,3,3,3,3,3,3,
        4,4,4,4,4,4,4,4,
        5,5,5,5,50,5,5,5,
        6,6,6,6,6,6,6,6,
        7,7,7,7,7,7,7,7,
        8,8,8,8,8,8,8,9
    ];

    actor SourceA() ==> double OutA:
        uint index_A := 0;
        transmit:
            action ==> OutA:[A[index_A-1]]
            guard index_A < M*K
            do
                index_A := index_A + 1;
            end
        end


    // procedure PrintMatrix(List(type:double, size=rows*cols) mat, uint rows, uint cols)
    // begin
    //     foreach uint i in 0..rows-1 do
    //         foreach uint j in 0..cols-1 do
    //             print(mat[i * cols + j] + " ");
    //             if((j+1) mod cols = 0) then println(""); end
    //         end
    //     end
    // end

    actor QRDecomposition(uint rows, uint cols) double InA ==> double OutQ, double OutR:
        // ========== Global Variables ==========

        // Size of the matrix
        uint sizeA = rows*cols;

        // Value used to track the number of elements received
        // from the input matrix A
        uint receivedA := 0;

        // Value used to track the number of elements sent
        // to the output matrices Q and R
        uint sent := 0;

        // Temporary storage for the input matrix A
        List(type:double, size=sizeA) matA;
        // Temporary storage for the output matrices Q and R
        List(type:double, size=rows*cols) matQ;
        List(type:double, size=rows*cols) matR;

        // Temporary storage for the stnd_basis matrix
        List(type:double, size=rows*cols) stnd_basis;

        // Passes done for decomposition
        int passes_done := 0;

        // Flag to check if the transpose is done (which means QR is done as well)
        bool transpose_done := false;

        // ========== Actions ==========

        // Copy the input matrix A to the temporary storage
        receiveA:
            action InA:[r] ==>
            do
                // Copy data from InA to matA
                matA[receivedA] := r;
                // Copy data from InA to matR (R should be the same as A to start)
                matR[receivedA] := r;
                receivedA := receivedA + 1;
            end

        // Perform the householder transformation
        qr_decomposition:
            action ==>
            guard receivedA = sizeA, passes_done < rows
            var
                List(type:double, size=rows) x,
                List(type:double, size=rows) basis,

                double norm,
                double alpha,

                List(type:double, size=rows) u,
                double norm_u_squared,

                List(type:double, size=rows * rows) H,
                List(type:double, size=rows * rows) outer_product,
                
                List(type:double, size=rows * cols) temp_mat,
                double sum,

                bool is_upper_triangular := true,

                List(type:double, size=cols * rows) Q_transposed
            do
                // Init Q and stnd_basis
                if (passes_done = 0) then
                    foreach int i in 0..rows-1 do
                        foreach int j in 0..cols-1 do
                            if (i = j) then
                                matQ[i * cols + j] := 1.0;
                                stnd_basis[i * cols + j] := 1.0;
                            else
                                matQ[i * cols + j] := 0.0;
                                stnd_basis[i * cols + j] := 0.0;
                            end
                        end
                    end
                end
                
                // Initialize x
                foreach int i in 0..rows-1 do
                    x[i] := matR[i * cols + passes_done];
                end
                foreach int i in 0..passes_done-1 do
                    x[i] := 0.0;
                end
                
                // Initialize basis
                foreach int i in 0..rows-1 do
                    basis[i] := stnd_basis[i * cols + passes_done];
                end

                // Compute norm
                norm := 0.0;
                foreach int i in 0..rows-1 do
                    norm := norm + x[i] * x[i];
                end
                norm := sqrt(norm);

                // Compute alpha 
                if (x[passes_done] >= 0) then
                    alpha := -norm;
                else
                    alpha := norm;
                end

                // Initialize U
                // print("X:");
                // foreach int i in 0..rows-1 do
                //     print(x[i] + " ");
                // end
                foreach int i in 0..rows-1 do
                    u[i] := x[i] - alpha * basis[i];
                end

                // Print U
                // print("U:");
                // foreach int i in 0..rows-1 do
                //     print(u[i] + " ");
                // end
                // println("");

                // Compute norm of U
                norm_u_squared := 0.0;
                foreach int i in 0..rows-1 do
                    norm_u_squared := norm_u_squared + u[i] * u[i];
                end
                // println("Norm of U:" + norm_u_squared);

                // If norm_u_squared is 0, then we skip the transformation
                if (my_fabs(norm_u_squared) < 1.0e-7) then
                    passes_done := passes_done + 1;
                else
                    // Householder transformation
                    // Init H
                    foreach int i in 0..rows-1 do
                        foreach int j in 0..rows-1 do
                            if (i = j) then
                                H[i * rows + j] := 1.0;
                            else
                                H[i * rows + j] := 0.0;
                            end
                        end
                    end
                    // Compute outer product
                    foreach int i in 0..rows-1 do
                        foreach int j in 0..cols-1 do
                            outer_product[i * rows + j] := u[i] * u[j];
                        end
                    end
                    // println("Outer product:");
                    // foreach int i in 0..rows-1 do
                    //     foreach int j in 0..cols-1 do
                    //         print(outer_product[i * rows + j] + " ");
                    //     end
                    //     println("");
                    // end
                    // Compute H
                    foreach int i in 0..(rows*cols)-1 do
                        H[i] := H[i] - (2.0 * outer_product[i] / norm_u_squared);
                    end
                    // Q = H * Q
                    foreach int i in 0..rows-1 do
                        foreach int j in 0..cols-1 do
                            sum := 0.0;
                            foreach int k in 0..rows-1 do
                                sum := sum + H[i * rows + k] * matQ[k * cols + j];
                            end
                            temp_mat[i * cols + j] := sum;
                        end
                    end
                    // Copy TempQ to matQ
                    foreach int i in 0..(rows*cols)-1 do
                        matQ[i] := temp_mat[i];
                    end

                    // R = H * R
                    foreach int i in 0..rows-1 do
                        foreach int j in 0..cols-1 do
                            sum := 0.0;
                            foreach int k in 0..rows-1 do
                                sum := sum + H[i * rows + k] * matR[k * cols + j];
                            end
                            temp_mat[i * cols + j] := sum;
                        end
                    end
                    // Copy TempR to matR
                    foreach int i in 0..(rows*cols)-1 do
                        matR[i] := num_s(temp_mat[i]);
                    end

                    // println("Matrix R:");
                    // PrintMatrix(matR, rows, cols);

                    // Check if R is upper triangular
                    is_upper_triangular := true;
                    foreach int i in 0..rows-1 do
                        foreach int j in 0..i-1 do
                            if (matR[i * cols + j] != 0.0) then
                                is_upper_triangular := false;
                            end
                        end
                    end

                    if (is_upper_triangular) then
                        // Stop execution if R is upper triangular
                        passes_done := rows;
                    else
                        passes_done := passes_done + 1;
                    end
                end

                // If passes_done is equal to rows, then we are done
                // so we need to transpose Q
                if (passes_done = rows) then
                    foreach int i in 0..rows-1 do
                        foreach int j in 0..cols-1 do
                            Q_transposed[j * rows + i] := matQ[i * cols + j];
                        end
                    end
                    foreach int i in 0..(rows*cols)-1 do
                        matQ[i] := Q_transposed[i];
                    end
                    transpose_done := true;
                end
            end

        // Send the output matrices Q and R
        transmit:
            action ==> OutQ:[matQ[sent-1]], OutR:[matR[sent-1]]
            guard passes_done >= rows, sent < rows*cols, transpose_done = true
            do
                sent := sent + 1;
            end

        end

    actor DisplayResults(uint rows, uint cols) double InQ, double InR ==>:
        bool print_done := false;

        uint receivedQ := 0;
        uint receivedR := 0;

        List(type:double, size=rows*cols) matQ;
        List(type:double, size=rows*cols) matR;

        receiveQ:
            action InQ:[r] ==>
            do
                // Copy data from InQ to matQ
                matQ[receivedQ] := r;
                receivedQ := receivedQ + 1;
            end

        receiveR:
            action InR:[r] ==>
            do
                // Copy data from InR to matR
                matR[receivedR] := r;
                receivedR := receivedR + 1;
            end

        print_results:
            action ==>
            guard receivedQ = rows*cols, receivedR = rows*cols, print_done = false
            do
                println("Matrix Q:");
                foreach uint i in 0..rows-1 do
                    foreach uint j in 0..cols-1 do
                        print(matQ[i * cols + j] + " ");
                        if((j+1) mod cols = 0) then println(""); end
                    end
                end

                println("Matrix R:");
                foreach uint i in 0..rows-1 do
                    foreach uint j in 0..cols-1 do
                        print(matR[i * cols + j] + " ");
                        if((j+1) mod cols = 0) then println(""); end
                    end
                end

                print_done := true;
            end
        end
        

    network Top() ==> :
        entities
            sourceA = SourceA();
            QRDec = QRDecomposition(rows=M, cols=K) { partition = "hw"; };
            printer = DisplayResults(rows=M, cols=K);
        structure
            sourceA.OutA --> QRDec.InA;
            QRDec.OutQ --> printer.InQ;
            QRDec.OutR --> printer.InR;
        end
end
