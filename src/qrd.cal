namespace qrd:
    import all math;

    import entity io.FileSource;
    import entity parser.FileParser;

    // List(type:double, size=M*K) A = [
    //     1,1,1,1,1,1,1,1,
    //     2,2,2,2,2,2,2,2,
    //     3,3,3,3,3,3,3,3,
    //     4,4,4,4,4,4,4,4,
    //     5,5,5,5,50,5,5,5,
    //     6,6,6,6,6,6,6,6,
    //     7,7,7,7,7,7,7,7,
    //     8,8,8,8,8,8,8,9
    // ];

    // actor SourceA(uint rows, uint cols) ==> double OutA, uint OutM, uint OutK:
    //     uint index_A := 0;
    //     bool tsize := false;

    //     transmit_size:
    //         action ==> OutM:[rows], OutK:[cols]
    //         guard not tsize
    //         do
    //             tsize := true;
    //         end
        
    //     transmit_data:
    //         action ==> OutA:[A[index_A-1]]
    //         guard tsize = true, index_A < rows * cols
    //         do
    //             index_A := index_A + 1;
    //         end
    //     end


    // procedure PrintMatrix(List(type:double, size=rows*cols) mat, uint rows, uint cols)
    // begin
    //     foreach uint i in 0..rows-1 do
    //         foreach uint j in 0..cols-1 do
    //             print(mat[i * cols + j] + " ");
    //             if((j+1) mod cols = 0) then println(""); end
    //         end
    //     end
    // end

    actor QRDecomposition() double InA, uint InM, uint InK ==> double OutQ, double OutR:
        // ========== Global Variables ==========

        // Size of the matrix
        uint rows = 0;
        uint cols = 0;
        uint sizeA = 0;

        // Value used to track the number of elements received
        // from the input matrix A
        uint receivedA := 0;

        // Value used to track the number of elements sent
        // to the output matrices Q and R
        uint sent := 0;

        // Temporary storage for the input matrix A
        List(type:double, size=M*K) matA;
        // Temporary storage for the output matrices Q and R
        List(type:double, size=M*K) matQ;
        List(type:double, size=M*K) matR;

        // Temporary storage for the stnd_basis matrix
        List(type:double, size=M*K) stnd_basis;

        // Passes done for decomposition
        int passes_done := 0;

        // Flag to check if the transpose is done (which means QR is done as well)
        bool transpose_done := false;

        // ========== Actions ==========

        // Receive the size of the matrix
        receive_size:
            action InM:[r], InK:[c] ==>
            do
                rows := r;
                cols := c;
                sizeA := rows * cols;
            end

        // Copy the input matrix A to the temporary storage
        receive_A:
            action InA:[r] ==>
            guard receivedA < sizeA, rows > 0, cols > 0
            do
                // Copy data from InA to matA
                matA[receivedA] := r;
                // Copy data from InA to matR (R should be the same as A to start)
                matR[receivedA] := r;
                receivedA := receivedA + 1;
            end

        // Perform the householder transformation
        qr_decomposition:
            action ==>
            guard receivedA = sizeA, passes_done < rows
            var
                List(type:double, size=M) x,
                List(type:double, size=M) basis,

                double norm,
                double alpha,

                List(type:double, size=M) u,
                double norm_u_squared,

                List(type:double, size=M*K) H,
                List(type:double, size=M*M) outer_product,
                
                List(type:double, size=M*K) temp_mat,
                double sum,

                bool is_upper_triangular := true,

                List(type:double, size=M*K) Q_transposed
            do
                // Init Q and stnd_basis
                if (passes_done = 0) then
                    foreach int i in 0..rows-1 do
                        foreach int j in 0..cols-1 do
                            if (i = j) then
                                matQ[i * cols + j] := 1.0;
                                stnd_basis[i * cols + j] := 1.0;
                            else
                                matQ[i * cols + j] := 0.0;
                                stnd_basis[i * cols + j] := 0.0;
                            end
                        end
                    end
                end
                
                // Initialize x
                foreach int i in 0..rows-1 do
                    x[i] := matR[i * cols + passes_done];
                end
                foreach int i in 0..passes_done-1 do
                    x[i] := 0.0;
                end
                
                // Initialize basis
                foreach int i in 0..rows-1 do
                    basis[i] := stnd_basis[i * cols + passes_done];
                end

                // Compute norm
                norm := 0.0;
                foreach int i in 0..rows-1 do
                    norm := norm + x[i] * x[i];
                end
                norm := sqrt(norm);

                // Compute alpha 
                if (x[passes_done] >= 0) then
                    alpha := -norm;
                else
                    alpha := norm;
                end

                // Initialize U
                // print("X:");
                // foreach int i in 0..rows-1 do
                //     print(x[i] + " ");
                // end
                foreach int i in 0..rows-1 do
                    u[i] := x[i] - alpha * basis[i];
                end

                // Print U
                // print("U:");
                // foreach int i in 0..rows-1 do
                //     print(u[i] + " ");
                // end
                // println("");

                // Compute norm of U
                norm_u_squared := 0.0;
                foreach int i in 0..rows-1 do
                    norm_u_squared := norm_u_squared + u[i] * u[i];
                end
                // println("Norm of U:" + norm_u_squared);

                // If norm_u_squared is 0, then we skip the transformation
                if (my_fabs(norm_u_squared) < 1.0e-7) then
                    passes_done := passes_done + 1;
                else
                    // Householder transformation
                    // Init H
                    foreach int i in 0..rows-1 do
                        foreach int j in 0..rows-1 do
                            if (i = j) then
                                H[i * rows + j] := 1.0;
                            else
                                H[i * rows + j] := 0.0;
                            end
                        end
                    end
                    // Compute outer product
                    foreach int i in 0..rows-1 do
                        foreach int j in 0..cols-1 do
                            outer_product[i * rows + j] := u[i] * u[j];
                        end
                    end
                    // println("Outer product:");
                    // foreach int i in 0..rows-1 do
                    //     foreach int j in 0..cols-1 do
                    //         print(outer_product[i * rows + j] + " ");
                    //     end
                    //     println("");
                    // end
                    // Compute H
                    foreach int i in 0..(rows*cols)-1 do
                        H[i] := H[i] - (2.0 * outer_product[i] / norm_u_squared);
                    end
                    // Q = H * Q
                    foreach int i in 0..rows-1 do
                        foreach int j in 0..cols-1 do
                            sum := 0.0;
                            foreach int k in 0..rows-1 do
                                sum := sum + H[i * rows + k] * matQ[k * cols + j];
                            end
                            temp_mat[i * cols + j] := sum;
                        end
                    end
                    // Copy TempQ to matQ
                    foreach int i in 0..(rows*cols)-1 do
                        matQ[i] := temp_mat[i];
                    end

                    // R = H * R
                    foreach int i in 0..rows-1 do
                        foreach int j in 0..cols-1 do
                            sum := 0.0;
                            foreach int k in 0..rows-1 do
                                sum := sum + H[i * rows + k] * matR[k * cols + j];
                            end
                            temp_mat[i * cols + j] := sum;
                        end
                    end
                    // Copy TempR to matR
                    foreach int i in 0..(rows*cols)-1 do
                        matR[i] := num_s(temp_mat[i]);
                    end

                    // println("Matrix R:");
                    // PrintMatrix(matR, rows, cols);

                    // Check if R is upper triangular
                    is_upper_triangular := true;
                    foreach int i in 0..rows-1 do
                        foreach int j in 0..i-1 do
                            if (matR[i * cols + j] != 0.0) then
                                is_upper_triangular := false;
                            end
                        end
                    end

                    if (is_upper_triangular) then
                        // Stop execution if R is upper triangular
                        passes_done := rows;
                    else
                        passes_done := passes_done + 1;
                    end
                end

                // If passes_done is equal to rows, then we are done
                // so we need to transpose Q
                if (passes_done = rows) then
                    foreach int i in 0..rows-1 do
                        foreach int j in 0..cols-1 do
                            Q_transposed[j * rows + i] := matQ[i * cols + j];
                        end
                    end
                    foreach int i in 0..(rows*cols)-1 do
                        matQ[i] := Q_transposed[i];
                    end
                    transpose_done := true;
                end
            end

        // Send the output matrices Q and R
        transmit:
            action ==> OutQ:[matQ[sent-1]], OutR:[matR[sent-1]]
            guard passes_done >= rows, sent < rows*cols, transpose_done = true
            do
                sent := sent + 1;
            end

        end

    actor DisplayResults() double InA, double InQ, double InR, uint InM, uint InK ==>:
        bool print_done := false;

        uint rows := 0;
        uint cols := 0;

        uint receivedA := 0;
        uint receivedQ := 0;
        uint receivedR := 0;

        List(type:double, size=M*K) matA;
        List(type:double, size=M*K) matQ;
        List(type:double, size=M*K) matR;

        receive_size:
            action InM:[r], InK:[c] ==>
            guard rows = 0, cols = 0
            do
                rows := r;
                cols := c;
            end

        receiveA:
            action InA:[r] ==>
            guard rows > 0, cols > 0
            do
                // Copy data from InA to matA
                matA[receivedA] := r;
                receivedA := receivedA + 1;
            end

        receiveQ:
            action InQ:[r] ==>
            guard rows > 0, cols > 0
            do
                // Copy data from InQ to matQ
                matQ[receivedQ] := r;
                receivedQ := receivedQ + 1;
            end

        receiveR:
            action InR:[r] ==>
            guard rows > 0, cols > 0
            do
                // Copy data from InR to matR
                matR[receivedR] := r;
                receivedR := receivedR + 1;
            end

        print_results:
            action ==>
            guard rows > 0, cols > 0, receivedA = rows*cols, receivedQ = rows*cols, receivedR = rows*cols, print_done = false
            do
                println("Matrix A:");
                foreach uint i in 0..rows-1 do
                    foreach uint j in 0..cols-1 do
                        print(matA[i * cols + j] + " ");
                        if((j+1) mod cols = 0) then println(""); end
                    end
                end

                println("Matrix Q:");
                foreach uint i in 0..rows-1 do
                    foreach uint j in 0..cols-1 do
                        print(matQ[i * cols + j] + " ");
                        if((j+1) mod cols = 0) then println(""); end
                    end
                end

                println("Matrix R:");
                foreach uint i in 0..rows-1 do
                    foreach uint j in 0..cols-1 do
                        print(matR[i * cols + j] + " ");
                        if((j+1) mod cols = 0) then println(""); end
                    end
                end

                print_done := true;
            end
        end
        

    network Top() ==> :
        entities
            fileSource = FileSource();
            sourceA = FileParser();
            QRDec = QRDecomposition() { partition = "hw"; };
            printer = DisplayResults();
        structure
            // Send file bytes to parser
            fileSource.Out --> sourceA.In;

            // Send source A to QRDec
            sourceA.OutA --> QRDec.InA;

            // Send size of A to QRDec
            sourceA.OutM --> QRDec.InM;
            sourceA.OutK --> QRDec.InK;

            // Send the input matrix A to printer
            sourceA.OutA --> printer.InA;
            // Send the QR decomposition results to printer
            QRDec.OutQ --> printer.InQ;
            QRDec.OutR --> printer.InR;
            // Send the size of Q and R to printer as well            
            sourceA.OutM --> printer.InM;
            sourceA.OutK --> printer.InK;
        end
end
